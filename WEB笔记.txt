正向代理：作为一个媒介将互联网上获取的资源返回给相关联的客户端。代理和客户端在一个局域网，对于服务器是透明的
反向代理：根据客户端的请求，从后端的服务器上获取资源，然后再将这些资源返回给客户端。代理和服务器在一个局域网，对客户端是透明的
反向代理的作用：
    提高动态语言的I/O处理能力，Python、PHP、Java这样的动态服务的I/O处理能力不高，反向代理可以缓冲请求，交个后端一个完整的HTTP请求，同样，Nginx也可以缓冲响应，也达到了减轻后端的压力
    加密和SSL加速
    安全。它保护和隐藏了原始资源服务器，还可以用作应用防火墙防御一些网络攻击，比如DDoS
    负载均衡。它帮应用服务器分配请求，以达到资源使用率最佳、吞吐率最大、响应时间最小的目的
    缓存静态内容。代理缓存可以满足相当数量的网站请求，大大降低应用服务器上的负载
    支持压缩。通过压缩优化，可以提高网站访问速度，还能大大较少带宽的消耗

Nginx 是反向代理的最佳选择，


爬虫（Crawler）：让程序自动访问目标网站，解析页面，把需要的内容保存下来。让你的抓取行为和用户的访问网站的真实行为尽量一致
    1.使用代理。网站限制：单位时间内网页的请求次数，基于来源IP、UA等请求信息判断用户访问是否正常。分布式的使用多个服务器来抓取
    2.伪造UA字符串。每次请求都使用随机生成的UA
    3.选择解析HTML的方式。BeautifulSoup是一个可以从HTML或XML文件中提取数据的Python库。需要给它配置一个解释器，解析器提供了相同的、非常人性的接口，使用非常简单。
	常见解析器：
	html.parser   使用Python标准库自带的解析器，文档容错能力强，但是速度上没有优势
	lxml  是一个C语言实现的libxml2 和libxslt的Python绑定库，速度比其他的选择块很多，而且文档容错能力强
	html5lib  容错性最好，他的解析方式和其他解析器相比有所不同，它会以浏览器的方式解析文档
    4.使用Referfer   模仿一个从搜索引擎点击进来的请求，更不容易被封禁


==========================================================
使用多线程
	全局解释器锁（Global Interpreter Lock，GIL）：
		限制任何时间都仅有一个线程在执行。由于线程是 轻量级的，并且相互之间易于通信，GIL保护了所有全局的解释器和环境状态变量。
	如果不使用GIL，会带来包括死锁，争用条件和高复杂性在内的各种问题。
	由于GIL的限制，使用多线程的意义：
		1.Python 大部分是使用C语言编写的，一些标准库和第三方的模块也是用C编写的，而C语言代码是可以 获取和释放GIL的，这在一定程度上缓解了GIL的问题。一些重要的、需要更高运行效率的模块还可以使用C语言编写，这样就可以利用更多的CPU资源
		2.多线程适合解决由于网络、磁盘等资源造成的I/O阻塞问题，它利用了等待I/O的请求完成别阻塞而导致的CPU空闲时间。计算密集型的工作不适合使用多线程完成，因为计算需要CPU资源，如果CPU繁忙的话，使用多线程并没有更多的利用CPU空闲时间，反而由于CPU需要额外调度多线程，一级线程切换的各种开销，多线程的运行效率比单线程还要慢
	抓取HTTP代理列表，主要是网络请求，几乎没计算相关的工作，使用和使用多线程
	创建和销毁线程是一个比较重的开销，可以考虑使用线程池，重用线程池中的线程
	multiprocessing.dummy 模块 与 multiprocessing 模块的区别：
		前者是多线程，
		后者是多进程，
		相同点：接口都是一样的，方便地降低阿妈在多线程和多进程间切换
	如果数据共享时可能别修改，就需要加锁来保护它，以确保同一时刻只能有一个线程访问这个数据。
	线程模块提供了许多同步原语：锁（Lock）、信号量（Semaphore）、条件变量（Condition）、事件（Event）。但是最好的方法是使用Queue模块，线程安全的，可以降低程序的复杂度，代码清晰、可读性更强、

使用Gevent
	高并发编程时，采用多线程（或进程）是一种不可取得解决方案，因为线程（或进程）本质上都是操作系统的资源。每个线程都是需要额外占用内存的，由于线程的调度由操作系统完成，调度器会因为时间片用完等原因强制多去某个线程的控制权，开发者还需要考虑加锁、使用队列等操作，这些都容易造成高并发情况下的性能瓶颈。
	协程：用户空间线程，复杂的逻辑和异步都封装在底层，开发者还是在使用同步的方式编程，但这种协作式的任务调度可以让用户使用CPU的时间，除非自己放弃，否则不会被其他协作抢夺到控制权。
	Python2 通过yield 提供了对协程的基本支持，但是功能有限。第三方的Gevent为Python提供了完整的协程支持。
	Gevent是一个基于微线程库Greenlet的并发框架，虽然与直接使用Greenlet、Eventlet相比性能略低，但是它提供了线程模型编程相仿的接口，而且提供Monkey Patch方法，可以在运行时动态修改标准库里大部分的阻塞式系统调用，如socket、threading和select的模块，让其变为协作式运行。

	信号量（semaphore）可以用来保证多协程（或者线程）并发访问共享资源时不会发生冲突。


使用多进程
	使用多进程代替多线程可以有效避开GIL，因为每个进程都拥有自己的Python解释器实例，也就不受GIL的限制了。计算密集型的任务通常应该使用多进程方式，也就是使用multiprocessing模块。
	multiprocessing模块允许程序充分利用多处理器，并可以跨平台使用。I/O密集型的任务瓶颈主要在网络延迟，所以使用多线程或者多进程都可以

	concurrent.futures是Python3.2引入的用于处理并发的模块，它提供一种优雅的用多线程 或者 多进程实现并发的方式。
	TreadPoolExecutor 和 ProcessPoolExecutor 这两个执行器，分别禅城线程池和进程池。把清理不可用的代码改成使用ThreadPoolExecutor模式：
	Future 类还提供取消任务、检查任务状态*运行中或者已完成）等功能，也可以汇报执行结果或者执行时发生的异常。
	Future 是一种异步编程范式，它对异步过程调用的结果做了抽象，它并不关心具体的异步机制。无论是线程、网络，还是I/O，甚至RPC，只要是异步过程调用，都可以通过Future的概念统一处理。基于Future的接口可以简化代码编写，让各种异步操作以一种顺序的、更接近人类逻辑思维的方式编写异步代码。


方法				语义
OPTIONS			用于获取资源支持的所有HTTP方法
HEAD			用于只获取请求某个资源返回的头信息
GET 			用于从服务器获取某个资源的信息：
				1.完成请求后，返回状态码 200 OK
				2.完成请求后，需要返回被请求的资源详细信息
POST			用于创建新资源
				1.创建完成后，返回状态码 201 Created
				2.完成请求后，需要返回被创建的资源详细信息
PUT 			用于完整的替换资源或者创建指定身份的资源，比如创建id为123的某个资源
				1.如果是创建了资源，则返回201 Created
				2.如果是替换了资源，则返回201 OK
PATCH 			用于局部更新资源
				1.完成请求后，返回状态码 200 OK
				2.完成请求后，需要返回被修改的资源详细信息
				3.完成请求后，需要返回被修改的资源详细信息
DELETE			用于删除某个资源，完成请求后返回状态码 204 No Content
			



