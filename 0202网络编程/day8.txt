前情回顾

信号 ：在进程间通过信号传递讯息
    os.kill(pid,sig)  发送信号
    signal.alarm(sec) 设置时钟
    signal.pause() 阻塞等待
    signal.signal(sig,handler)  处理信号
                      SIG_DFL
		      SIG_IGN
		      fun(sig,frame)

信号量  semaphore
acquire()  消耗一个信号量
release()  添加一个信号量
get_value() 获取信号量的值

同步互斥机制
Event
Lock

多线程编程
  threading 创建线程
  线程对象属性
  自定义线程
***************************************************

* 创建父子进程分别表示司机和售票员
* 当售票员捕捉到SIGINT信号时，给司机发送SIGUSER1信号
  此时司机打印 "老司机开车了" 
  当售票员捕捉到SIGQUIT信号时，给司机发送SIGUSER2信号。此时司机打印 "车速有点快，系好安全带"
  当司机捕捉到SIGTSTP信号时，给售票员发送SIGUSER1信号。此时售票员打印 "到站了请下车"
* 到站后 售票员先下车（子进程先退出）然后司机下车


线程通信
   通信方法 ： 多个线程共用进程空间，所以进程的全局变             量对进程内线程均可见。线程往往使用全局             变量进行通信
   注意事项 ： 线程间使用全局变量进行通信，全局变量为             共享资源，往往需要同步互斥机制

线程的同步互斥

线程Event

创建对象：
    e = threading.Event()

事件阻塞函数
    e.wait([timeout])  

设置事件
    e.set()
  
清除事件
    e.clear（）
  

线程锁  Lock

lock = threading.Lock()   创建锁对象
lock.acquire()  上锁
lock.release()  解锁 

with  lock    上锁

python线程的GIL问题 

GIL （全局解释器锁）

python ---》 支持线程操作 ---》IO的同步和互斥 --》 加锁 ----》 超级锁，给解释器加锁

后果 ： 一个解释器，同一时刻只解释一个线程，此时其他         线程需要等待。大大降低了python线程的执行效率

python  GIL问题解决方案
* 修改c解释器
* 尽量使用多进程进行并行操作
* python线程可以用在高延迟多阻塞的IO情形
* 不使用cpython     c#   java做解释器

效率测试

分别测试 多进程  多线程  单进程执行相同的IO操作和CPU
操作的时间

Line cpu: 8.15166711807251
Line IO: 6.841825246810913

Thread cpu 8.414522647857666
Thread IO 6.023292541503906

Process cpu 4.079084157943726
Process IO 3.2132551670074463

进程和线程的区别和联系
1.两者都是多任务编程的方式，都能够使用计算机的多核
2.进程的创建删除要比线程消耗更多的计算机资源
3.进程空间独立，数据安全性好，有专门的进程间通信方法
4.线程使用全局变量通信，更加简单，但是需要同步互斥操   作
5. 一个进程可以包含多个线程，线程共享进程的空间资源
6. 进程线程都独立执行，有自己的特有资源如属性，id，    命令集等

使用情况：
* 一个进程中并发任务比较多，比较简单，适合使用多线程
* 如果数据程序比较复杂，特别是可能多个任务通信比较多   的时候，要考虑到使用线程同步互斥的复杂性
* 多个任务存在明显差异，和功能分离的时候没有必要一定   写入到一个进程中
* 使用python考虑线程GIL问题

要求：
1. 进程线程的区别和关系
2. 进程间都信方式都用过哪些，有什么特点
3. 同步和互斥是怎么回事，你都用哪些方法实现了同步互    斥
4. 什么是僵尸进程，怎么处理的
5. python线程的效率怎么样？GIL是怎么处理的


服务器模型

硬件服务器 ： 主机   集群
厂商 ： IBM  HP  联想  浪潮

软件服务器 ：编写的服务端程序，依托硬件服务器运行。              提供给用户一定的功能服务

服务器种类

webserver ---》 网络的后端应用程序，提供数据处理和逻                 辑处理
httpserver ---> 接受http请求，返回http响应

邮箱服务器 ---》 处理邮件请求，进行邮件收发

文件服务器 --》提供文件的上传下载存储

功能实现 ： 网络连接，逻辑处理，数据运算，数据交互
            协议实现，网络数据传输。。。。

模型结构 :   C/S   客户端服务器模型
             B/S    浏览器服务器模型

服务器目标：处理速度更快，数据安全性更强，并发量更高

硬件 ： 更高的配置，更好的硬件搭配，更高的网络速度
        更多的主机，网络安全投入

软件 ： 占有更少的计算机资源，更稳定的运行效率，更流         畅的速度，更强大的算法，更合理的技术搭配


网络服务器基础

循环服务器 ： 单进程程序，循环接受客户请求，处理请求。处理完毕再接受下一个请求。

特点 ： 每次只能处理一个客户端请求
        如果客户端长期占有服务器则无法处理其他客户端请求。

优点 ： 实现简单，占用资源少
缺点 ： 无法同时处理多客户端，体验差
使用情况 ： 任务短暂，可以快速完成。udp比tcp更适合循             环

并发服务器 ： 能够同时处理多个客户端任务请求

    IO 并发  :  IO多路复用     协程 
      
      优点 ： 可以实现IO的并发操作，占用系统资源少
      缺点 ： 不能监控cpu密集的情况，并能有长期阻塞

    多进程/多线程并发：为每个客户端单独提供一个进程/                     线程处理客户端请求 

      优点 ： 客户端可以长期占有服务器
      缺点 ： 消耗计算机资源较多

多进程并发模型

使用fork完成并发

1. 创建套接字，绑定，监听
2. 等待接受客户端连接请求
3. 创建新的进程处理客户端请求
   父进程继续等待连接其他客户端
4. 客户端退出 对应子进程结束


tftp 文件服务器

项目功能 ： 

* 客户端有简单的页面命令提示
* 功能包含：
1. 查看服务器文件库中的文件列表（普通文件）
2. 可以下载其中的某个文件到本地
3. 可以上传客户端文件到服务器文件库

* 服务器需求 ：1. 允许多个客户端同时操作
               2.每个客户端可能回连续发送命令

技术分析：
1. tcp套接字更适合文件传输
2. 并发方案  ---》 fork 多进程并发
3. 对文件的读写操作
4. 获取文件列表 ----》 os.listdir() 
   粘包的处理

整体结构设计
1. 服务器功能封装在类中（上传，下载，查看列表）
2. 创建套接字，流程函数调用  main（）
3. 客户端负责发起请求，接受回复，展示
   服务端负责接受请求，逻辑处理

编程实现

1. 搭建整体结构，创建网络连接
2. 创建多进程和类的结构
3. 每个功能模块的实现

作业 ： 补充完整 tftpserver的基本框架
        尝试实现 get或者put功能




