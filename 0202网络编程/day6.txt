前情回顾

1.孤儿进程  僵尸进程
2.聊天室
3.multiprocessing
  Process   start   join
****************************************************

Process（target,name,args,kwargs）

name : 给进程起名字
       默认为Process-1 Process-2.....
       p.name 可以获取进程名称

args : 以元组的形式给target函数传参

kwargs ： 以字典的形式给对应键的形参传参

进程对象的其他属性方法

p.name  p.start()  p.join() 

p.pid : 创建的新的进程的PID号
p.is_alive()  判断进程是否处于alive状态

p.daemon  默认为False 如果设置为True 则主进程退出时子           进程也会结束

* daemon 属性设置要在start() 前
* 设置daemon为True 则一般不需要加join

cookie
获取文件大小
size = os.path.getsize("./timg.jpeg")

注意：
如果多个子进程拷贝同一个父进程中的对象，则多个子进程使用的是同一个对象（如文件对象，套接字，队列，管道。。。）
如果是在创建子进程后单独创建的对象，则多个子进程各不相同

创建自定义进程类

1. 编写类继承Process
2. 在自定义类中加载父类__init__以获取父类属性，同时可以自定义新的属性
3. 重写run方法，在调用start时自动执行该方法

进程的缺点

进程在创建和销毁的过程中消耗的资源相对较多

进程池技术

产生原因 ： 如果有大量的任务需要多进程完成，而任务周期又比较短且需要频繁创建。此时可能产生大量进程频繁创建销毁的情况，消耗计算机资源较大


使用方法 ：
1. 创建进程池，在池内放入适当数量的进程
2. 将事件封装函数，放入到进程池
3. 事件不断运行，知道所有放入进程池事件运行完成
4. 关闭进程池，回收进程

from multiprocessing import  Pool

Pool(processes)
功能：创建进程池对象
参数：进程数量
返回 ： 进程池对象

pool.apply_async(fun,args,kwds)
功能 ： 将事件放入进程池执行
参数： fun 要执行的事件函数
       args  以元组为fun传参
       kwds  以字典为fun传参
返回值 ： 返回一个事件对象 通过get()属性函数可以获取
           fun的返回值

pool.apply(fun,args,kwds)
功能 ： 将事件放入进程池执行
参数： fun 要执行的事件函数
       args  以元组为fun传参
       kwds  以字典为fun传参
	 

pool.close()
功能: 关闭进程池，无法再加入事件

pool.join()
功能 ： 回收进程池

pool.map(func,iter)
功能 ： 将要执行的事件放入到进程池
参数 ： func 要执行的函数
        iter 迭代对象，给func传参
返回值 ： 返回 func的返回值列表


进程间通信（IPC）

由于进程间空间独立，资源无法共享，此时在进程间通信就需要专门的通信方法。

进程间通信方法 ： 管道  消息队列  共享内存  信号
                   信号量    套接字

管道通信

在内存中开辟一块空间，形成管道结构，多个进程使用同一个管道，即可通过对管道的读写操作进行通信

multiprocessing ---》 Pipe

fd1,fd2 = Pipe(duplex = True)
功能: 创建管道
参数：默认表示双向管道
      如果设置为False则为单向管道
返回值 ： 两个管道对象，分别表示管道的两端
          如果是双向管道则均可读写
	  如果是单向管道则fd1只读 fd2只写

fd.recv()
功能:从管道读取信息
返回值 ：读取到的内容

* 当管道为空则阻塞

fd.send(data)
功能: 向管道写入内容
参数： 要写入的内容

* 管道满时会阻塞
* 可以写入几乎所有的python数据

消息队列

队列 ： 先进先出

在内存中开辟队列结构空间，对多个进程可见。多个进程操作同一个队列对象可以实现消息的存取工作。

创建队列
q = Queue(maxsize = 0)
功能 ： 创建队列对象
参数 ： maxsize ： 默认表示系统自动分配队列空间
        如果传入正整数则表示最多存放多少条消息
返回值 ： 队列对象

q.put(data,[block,timeout])
功能：向队列中存入消息
参数：data  存入的消息 （支持python数据类型）
      block  默认True 表示当队列满时阻塞
             设置为False 则为非阻塞
      timeout  超时时间 

data = q.get([block,timeout])
功能: 获取队列消息
参数：block  默认为True 表示队列空时阻塞
             设置为False则表示非阻塞
      timeout 超时时间
返回值 ： 返回获取到的消息

q.full()  判断队列是否为满
q.empty() 判断队列是否为空
q.qsize()  获取队列中消息数量
q.close()  关闭队列

共享内存

在内存中开辟一段空间，存储数据，对过个进程可见。每次写入共享内存中的内容都会覆盖之前的内容。对内存的读操作页不会改变内存中的内容

from multiprocessing Value，Array 

shm = Value(ctype,obj)
功能： 开辟共享内存空间
参数： ctype  字符串  要转变的c的类型
        obj  共享内存的初始数据
返回值 ： 返回共享内存对象

shm.value  表示共享内存中的值


shm = Array(ctype,obj)
功能 ： 开辟共享内存空间
参数 ： ctype ： 要转换的数据类型
        obj ： 要存入共享内存的数据
	      
	      * 列表、字符串 表示要存入的内容，要                   求类型相同
	      * 整数   表示要开辟几个单元的空间
返回值 ： 返回共享内存对象 可迭代对象


           管道         消息队列       共享内存 

开辟空间   内存          内存           内存

读写方式   两端读写     先进先出    每次覆盖上次内容
           双向/单向                   

效率       一般         一般            较快

应用      多用于父子   应用灵活广泛   复杂，需要同步
          进程                         互斥操作


作业 ： 熟练进程间通信和进程池的使用
        复习类的使用


