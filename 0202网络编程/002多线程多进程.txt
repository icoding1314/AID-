崔庆才的教材：
https://cuiqingcai.com/3335.html
《python核心编程(第三本)》、《数据分析》、《爬虫》、《数据结构》《网站》、《python  web》


多任务编程
  意义： 充分利用计算机资源，同时运行多个任务，提高程序整体的运行效率
  定义 ： 通过程序利用计算机的多个核心达到同时执行多个任务的目的。以此达到提升程序运行效率的目的
  实施方案 ： 多进程编程   多线程编程
并行：多个计算机核心在同时处理多个任务，这时多个任务之间是并行关系
并发：单核心，同时运行多个任务，内核在多个任务间不断切换，达到多个任务都会被执行的处理效果。此时多个任务间是并发关系。比如：IO多路复用
程序 ： 是一个可执行文件，是静态的，占有磁盘，不占计算机的运行资源
进程：程序在计算机中的一次执行过程
  进程 ： 进程是一个动态的过程，占有计算机资源，有一定的生命周期
    * 同一个程序不同的运行过程是不同的进程。因为分配的资源和生命周期都不相同
  进程的创建流程
    1. 用户启动一个程序或者调用接口发起进程创建
    2. 操作系统接收用户请求分配计算机资源创建进程
    3. 操作系统将一定状态的进程提供给用户使用
    4. 用户利用操作系统提供的进程完成任务
进程相关概念
  1.cpu时间片：如果一个进程占有cpu此时我们称为该进程占有cpu时间片。多个进程任务会轮流占有cpu时间片形成并发效果。
  2.进程信息 （process）：PCB （进程控制块）：进程创建后会自动在内存生产一个空间存放进程信息。
  3.进程信息 （process）： 进程的ID 进程占有内存的位置，创建时间，创建用户。。。
  4.查看系统该进程信息（process） ：  ps  -aux
  5.PID(process ID) : 在操作系统中每个进程都有唯一的PID值是由系统分配的。
  6.进程特征
    * 进程是操作系统分配资源的最小单元
    * 每个进程拥有自己独立的运行空间 （虚拟内存空间）
    * 进程之间运行相互独立互不影响
  7.进程的状态
    三态
      * 就绪态 ： 进程具备执行条件，等待系统分配处理器资源进入运行态
      * 运行态 ： 进程占有cpu处于运行状态
      * 等待态 ： 进程暂时不具备运行条件，需要阻塞等待
    五态 （三态基础上增加新建和终止）
      * 新建 ： 创建一个新的进程，获取系统资源的过程
      * 终止 ： 进程执行结束，释放资源的过程

     ps -aux  ---> STAT表示进程状态

     D  等待态 阻塞   不可中断等待态
     S  等待态 睡眠   可中断等待态
     T  等待态 暂停   暂停执行
     R  运行态（就绪态）
     Z  僵尸

     + 前台进程 （在终端运行）
     <  有较高优先级的进程
     N  较低优先级的进程
     s  会话组
     l  有进程连接
  8.进程的优先级
    top 动态查看进程优先级
    <  > （按住shift键）进行翻页  q退出
    优先级的取值范围 ：   -20  ---  19    -20最高
    nice ： 以指定的优先级运行一个程序
    nice   -9   ./while.py  以9的优先级运行
    sudo nice   --9   ./while.py  以-9优先级运行
    首行添加：#! /usr/bin/python3 可以直接运行，有可执行权限
父子进程
  在系统中除了初始化进程每个进程都有一个父进程，可能有0个或多个子进程。由此形成进程间的父子关系。
  便于进程管理，父进程发起创建子进程请求
  查看进程树： pstree
    终端启动的进程的父进程为bash（shell命令行）
  查看父子进程PID ：  ps  -ajx
僵尸进程 与 孤儿进程：
  孤儿进程 ：  当父进程先于子进程退出，此时子进程就会成为孤儿进程。
    * 孤儿进程会被系统指定进程收养，即系统进程会成为孤儿进程新的父进程。系统进程会自动处理孤儿进程退出状态。孤儿进程不会成为僵尸进程

  僵尸进程 ： 子进程先于父进程退出，父进程没有处理子进程的退出状态，此时子进程就会成为僵尸进程
    * 僵尸进程会滞留部分PCB信息在内存中，大量的僵尸进程会消耗系统的内存资源，所以要尽量避免僵尸进程产生

  如何避免僵尸进程产生
    * 父进程先退出 -->>> (不容易控制，可以通过逻辑进行解决；见以下1，2)
    * 父进程处理子进程退出状态
  1.pid,status = os.wait()
    功能 ： 在父进程中阻塞等待处理子进程的退出，同程序块的后续语句将等到wait执行完后，才能执行
    返回值：
        pid  退出的那个子进程的PID号
        status  子进程的退出状态  512=256*2
    os.WEXITSTATUS(status)
      功能：获取原来退出状态,就是os._exit(2) 获取的就是2，即原来的状态
  2.pid,status = os.waitpid(pid,option)   # 功能返回值同os.wait()
    功能 ： 在父进程中阻塞等待处理子进程的退出
    参数 ：
      pid    -1  表示等待任意子进程退出
             >0  表示等待对应PID号的子进程退出
      option  0   表示阻塞等待
              WNOHANG  表示非阻塞  #仍会产生僵尸进程，可以使用while True ，if pid > 0:时，表示没有子进程，break
    返回值：
      pid  退出的那个子进程的PID号
      status  子进程的退出状态
      返回值为0 0：表示的是非阻塞状态，此时子进程还未退出，父进程没能对子进程进行处理

    waitpid(-1,0)  ==等价==> wait()
  3.创建二级子进程 # 类似于父进程先退出
    父进程创建子进程等待子进程退出
    子进程创建下一级子进程，然后立即退出
    二级子进程成为孤儿，处理具体工作
    僵尸态  ---->>>> 孤儿态（孤儿进程由系统接管）
    父进程 --->>> 子进程(创建子子进程后，立即退出) --->>> 子子进程(成为孤儿态，由父进程接管)

  4.利用信号处理僵尸进程

os.fork 创建进程
  pid = os.fork()
    功能 ： 创建进程
    返回值：
      失败 ：返回一个负数
      成功 ：在原有进程中返回新进程的PID号，在新进程中返回0
    * 子进程会复制父进程全部内存空间，包括代码段
    * 子进程会从fork的下一句开始执行
    * 父进程中fork返回值即为新创建子进程的PID号
    * 父子进程不一定谁先执行，执行上互不干扰，抢占时间片
    * 使用if 语句结构使父子进程执行不同的代码几乎是fork创建进程的固定结构
    * 在子进程中对变量等其他内容的修改，不会影响父进程中的内容
    * 子进程虽然复制父进程内容，但是也有自己的特有属性特征。比如： PID号 PCB 内存区间等
获取进程PID
  os.getpid()
    功能：获取进程的PID号
    返回值 ： 返回进程的PID号
  os.getppid()
    功能：获取父进程的PID号
    返回值 ： 返回父进程的PID号
进程退出
  os._exit(status)
    功能 ： 退出一个进程
    参数 ： 进程的退出状态  整数 （0表示正常退出）【是人为的一个约定，可以随便传入】
  sys.exit([status] )
    功能 ： 退出一个进程
    参数 ： 默认为0
            相同点：如果传入一个整数则同 _exit()
            不同点：传入一个字符串，则在退出时打印该字符串
    * sys.exit() 可以通过捕获 SystemExit异常阻止退出

multiprocessing 模块创建进程
  1. 需要将要做的事情封装成函数
  2. 使用multiprocessing提供的类Process创建进程对象
  3. 通过进程对象和Process初始化进程进行进程的设置，绑定函数
  4. 启动进程，会自动执行绑定的函数
  5. 完成进程的回收
  Process(target,name,args,kwargs)
    功能： 创建进程对象
    参数：
      target ： 要绑定的函数
      name ： 给进程起的名称 （默认Process-1 Process-2.....）
              p.name 可以获取进程名称
      args： 元组 用来给target函数位置传参
      kwargs : 字典  用来给target函数键值传参
  p.start()

    功能 ： 启动进程 且只 自动运行terget绑定函数。此时进程被创建
  p.join([timeout])
    功能： 阻塞等待子进程退出  ##说明：join会阻塞等待依次退出
    参数： 超时时间
  multiprocessing说明：
    * 使用multiprocessing创建进程子进程同样复制父进程的全部内存空间，之后有自己独立的空间，执行上互不干扰
    * 子进程也是有自己特有的PID等资源
    * 如果不使用join回收可能会产生僵尸进程
    * 使用multiprocessing创建子进程，一般父进程功能就是创建子进程/回收子进程，所有事件交给子进程完成
  进程对象的其他属性方法
    p.name
    p.pid : 创建的新的进程的PID号
    p.daemon  默认为False, 则主进程退出时，子进程不一定结束
              如果设置为True 则主进程退出时，子进程也会结束
      * daemon 属性设置要在start() 前
      * 设置daemon为True 则一般不需要加join
      * python中的daemon与Linux中的守护进程是不一样的

    p.start()： 启动进程 且只 自动运行target绑定函数。此时进程被创建
    p.join([timeout])： 阻塞等待子进程退出
    p.is_alive()  判断进程是否处于alive状态
  注意：
    如果多个子进程拷贝同一个父进程中的对象，则多个子进程使用的是同一个对象（如文件对象，套接字，队列，管道。。。）
    如果是在创建子进程后单独创建的对象，则多个子进程各不相同
  创建自定义进程类
    1. 编写类继承Process
    2. 在自定义类中加载父类__init__以获取父类属性，同时可以自定义新的属性
      super().__init__()
    3. 重写run方法，在调用start时自动执行该方法
进程池技术:
  进程的缺点:进程在创建和销毁的过程中消耗的资源相对较多
  产生原因 ： 如果有大量的任务需要多进程完成，而任务周期又比较短且需要频繁创建。此时可能产生大量进程频繁创建销毁的情况，消耗计算机资源较大
  使用方法 ：
    1. 创建进程池，在池内放入适当数量的进程(根据计算机内核数量，4个核心，就创建4个来并行，多了就会形成并发)
    2. 将事件封装函数，放入到进程池
    3. 事件不断运行，直到所有放入进程池事件运行完成
    4. 关闭进程池，回收进程
  from multiprocessing import  Pool（类）
    pool = Pool(processes=4)
      功能：创建进程池对象
      参数：进程数量，即 每次运行的最大数量。超过4个将并发执行
      返回 ： 进程池对象
    pool.apply_async(fun,args,kwds)  # async 异步执行
      功能 ： 将事件放入进程池执行
      参数：
        fun 要执行的事件函数
        args  以元组为fun传参
        kwds  以字典为fun传参
      返回值 ： 返回一个事件对象 通过.get()属性函数可以获取fun的返回值
    pool.close()
      功能: 关闭进程池，无法再加入事件
    pool.join()
      功能 ： 回收进程池

    pool.apply(fun,args,kwds)  # 同步执行 且 没有返回值 ** 很少使用
      功能 ： 将事件放入进程池执行
      参数：
        fun 要执行的事件函数
        args  以元组为fun传参
        kwds  以字典为fun传参
    pool.map(func,iter)
      功能 ： 将要执行的事件放入到进程池
      参数 ： func 要执行的函数
              iter 迭代对象，给func传参
      返回值 ： 返回 func的返回值列表

进程间通信（IPC）:由于进程间空间独立，资源无法共享，此时在进程间通信就需要专门的通信方法。 eg:通过微信登录其他app账号
  进程间通信方法 ： 管道  消息队列  共享内存  信号  信号量    套接字

  1.管道通信:在内存中开辟一块空间，形成管道结构，多个进程使用同一个管道，即可通过对管道的读写操作进行通信。
      ** 在父进程中创建管道  实现父子进程间通信
      ** 需要与Process配合使用
    multiprocessing ---》 Pipe
    fd1,fd2 = Pipe(duplex = True)
      功能: 创建管道
      参数：默认表示双向管道
           如果设置为False则为单向管道
      返回值 ： 两个管道对象，分别表示管道的两端
          如果是双向管道则均可读写
          如果是单向管道则fd1只读 fd2只写
    fd.recv()
      功能:从管道读取信息
      返回值 ：读取到的内容
      * 当管道为空则阻塞
    fd.send(data)
      功能: 向管道写入内容
      参数： 要写入的内容
      * 管道满时会阻塞
      * 可以写入几乎所有的python数据，不同于socket中的send()
  2.消息队列:队列 ： (先进先出FIFO):在内存中开辟队列结构空间，对多个进程可见。多个进程操作同一个队列对象可以实现消息的存取工作。
    multiprocessing ---》Queue  # put get 是IO操作，运行时间叫CPU长
    q = Queue(maxsize = 0)
      功能 ： 创建队列对象
      参数 ： maxsize ： 默认表示系统自动分配队列空间
              如果传入正整数则表示最多存放多少条消息
      返回值 ： 队列对象
    q.put(data,[block,timeout])
      功能：向队列中存入消息
      参数：data  存入的消息 （支持python数据类型）
            block  默认True 表示当队列满时阻塞
                   设置为False 则为非阻塞
            timeout  超时时间
    data = q.get([block,timeout])
      功能: 获取队列消息
      参数：block  默认为True 表示队列空时阻塞
                   设置为False则表示非阻塞
            timeout 超时时间
      返回值 ： 返回获取到的消息
    q.full()  判断队列是否为满   ***如果设置为非阻塞 | 超时，则产生Full异常
    q.empty() 判断队列是否为空
    q.qsize()  获取队列中消息数量
    q.close()  关闭队列
    q.task_done()  清除任务
  3.共享内存:在内存中开辟一段空间，存储数据，对过个进程可见。每次写入共享内存中的内容都会覆盖之前的内容。对内存的读操作也不会改变内存中的内容
    from multiprocessing import Value, Array
    shm = Value(ctype,obj)   --->>>> 配合Process一起使用
      # shm  (share memory)
      功能： 开辟共享内存空间
      参数： ctype  字符串  要转变的c的类型
             obj  共享内存的初始数据
      返回值 ： 返回共享内存对象
      shm.value  表示共享内存中的值  对value的修改就是对共享内存的修改
    shm = Array(ctype,obj)     --->>>> 配合Process一起使用
      功能 ： 开辟共享内存空间
      参数 ： ctype ： 要转换的数据类型
              obj ： 要存入共享内存的数据 ##[可以是结构化的数据]
                * 列表、字符串 表示要存入的内容，要求类型相同
                * 整数   表示要开辟几个单元的空间，默认用0填充内容
                  eg:为5，则有[0, 0, 0, 0, 0]
      返回值 ： 返回共享内存对象 可迭代对象(不同于迭代器的对象，原理不同，用法一样，可以用[]取值)
      shm.value  # 从共享内存的首地址取值
  --------------------------------------------------------------
  _____________________________________________________________
             管道         消息队列       共享内存

  开辟空间   内存          内存           内存

  读写方式   两端读写     先进先出    每次覆盖上次内容
             双向/单向

  效率       一般         一般            较快

  应用      多用于父子   应用灵活广泛   复杂，需要同步
            进程互斥操作
  _________________________________________________________________
  4.信号 :一个进程向另外一个进程通过信号的方式传递某种讯息。接收方在接收到信号后作出相应的处理。
    $ kill  -l   查看所有信号信息，见如下E.G.
    $ kill  -sig(数字)  PID(进程号)   向一个进程发送信号
    关于信号
      信号名称 ： 系统定义，名字或者数字
      信号含义 ： 系统定义，信号的作用
      默认处理方法 ：系统定义， 当一个进程接收到信号时，默认产生的效果
                     终止进程    暂停进程    忽略发生
      E.G.
        1  SIGHUP   断开连接   终止进程(进程正在运行，点击右上窗口的X)
        2  SIGINT   ctrl-c     终止进程
        3  SIGQUIT  ctrl-\     终止进程
        20 SIGTSTP  ctrl-z     暂停进程(不可取)
        9  SIGKILL  终止进程且不能被处理（必须被终止）
        19 SIGSTOP  暂停进程且不能被处理（必须被暂停）
        14 SIGALRM  时钟信号
        17 SIGCHLD  子进程状态改变发送给父进程信号

    import os, signal
          # python信号处理，进程间通用，信号是唯一一个异步处理方式
          # 程序执行完，还会对后续程序产生影响（异步执行）
          # 无论当前程序在执行什么，收到信号后要立即执行
    os.kill(pid,sig)
      功能 ： 发送一个信号给某个进程
      参数 ： pid  给哪个进程发送信号
              sig  要发送什么信号
    signal.alarm(sec)
      功能: 设置时钟信号  在一定时间后给自身发送SIGALRM信号
      参数： sec  时间（秒）
        * 一个进程中只能有一个时钟，后来的时候会覆盖前面的时间
    程序的同步执行和异步执行
      同步 ： 程序按照步骤一步一步执行，呈现一个先后性和顺序性
      异步 ： 程序在执行中利用内核功能帮助完成必要的辅助操作，不影响应用层持续执行

    signal.pause()
      功能： 阻塞进程，等待一个信号
    signal.signal(sig,handler)  # signal是一个高阶函数
      功能 ： 处理信号
      参数 ： sig  要处理的信号
              handler  信号处理方法
               可选值 ：
                  SIG_DFL  表示使用默认方法处理
                  SIG_IGN  表示忽略这个信号
                  func   自定义函数
                    自定义函数格式 ： def func(sig,frame)
                    sig : 接收到的信号
                    frame ：信号结构对象

      * signal函数也是一个异步处理函数。只要执行了该函数，则进程任意时候接收到相应信号都会处理。
      * signal 是不能处理 SIGKILL SIGSTOP的
      * 父进程中可以用 signal(SIGCHLD,SIG_IGN)将子进程的退出交给系统处理
      * 信号是一种异步的进程间通信方法
  5.信号量:给定一定的数量，对多个进程可见，并且多个进程根据信号量多少确定不同的行为
    sem = Semaphore(num)
      功能 ： 创建信号量对象
      参数 ： 信号量的初始值
      返回 ： 信号量对象
    sem.acquire()  将信号量数量减1   当数量为0则阻塞
    sem.release()  将信号量数量加1
    sem.get_value()  获取当前信号量的值
  同步互斥机制
    目的 ： 解决对共有资源产生的资源争夺
    临界资源 ： 多个进程或者线程都能够操作的资源
    临界区 ： 操作临界资源的代码段
    同步 ： 同步是一种合作关系，为完成某个任务，多进程或者多线程之间形成一种协调，按照约定执行，相互告知，共同完成任务。
    互斥 ： 互斥是一种制约关系，当一个进程或者线程进入临界区操作资源时采用上锁的方式，阻止其他进程操作。直到解锁后才会让出资源
  Event 事件
    from multiprocessing import  Event
    创建事件对象:e = Event()
    事件阻塞:e.wait([timeout])
      功能 ： 使进程处于阻塞状态，直到事件对象被set
    事件设置:e.set()
      功能 : 让事件对象变为被设置状态
    清除设置:e.clear()
      功能 ： 使事件对象清除设置状态
    事件判断 判断当前事件对象的状态:e.is_set()
  锁  Lock : multiprocessing --》 Lock

    lock = Lock()   创建对象
    lock.acquire()  上锁
    lock.release()  解锁
      * 如果一个锁对象已经被上锁则再调用acquire会阻塞
      with  lock:    上锁
          ....
          ....
                     解锁

多线程
  线程 （thread）:线程也是一种多任务编程方式，可以使用计算机的多核资源。线程被称为轻量级的进程。
  线程特征：
    * 一个进程可以包含多个线程
    * 线程是计算机内核使用的最小单位
    * 线程也是一个运行过程，也要消耗计算机资源
    * 多个线程共享共用进程的资源
    * 线程也有自己的特征属性，TID 指令集，线程栈
    * 多个线程之间独立运行互不干扰
    * 线程的创建删除消耗的资源要小于进程
threading 模块的使用
  t = threading.Thread()
    功能 : 创建线程对象
    参数 ： target  线程函数
            name   线程名称 默认Thread-1
            args    元组  给线程函数位置传参
            kwargs  字典  给线程函数键值传参
    返回 ： 线程对象
  t.start()  启动线程
  t.join([timeout])  回收线程
  线程对象属性
    t.name 线程名称
    t.setName()   设置线程名称
    t.is_alive()  查看线程状态
    threading.currentThread()  获取到当前线程对象

    t.daemon 属性
    默认情况下主线程结束不会影响分支线程执行
    设置为True时主线程退出则分支线程也退出

    设置 daemon值
    t.setDaemon(True)
    t.daemon = True

    查看daemon值
    t.isDaemon()
  创建自己的线程类
    步骤 ：
      1 继承 Thread
      2 加载父类 __init__
      3 重写run

      * 创建父子进程分别表示司机和售票员
      * 当售票员捕捉到SIGINT信号时，给司机发送SIGUSER1信号
        此时司机打印 "老司机开车了"
        当售票员捕捉到SIGQUIT信号时，给司机发送SIGUSER2信号。此时司机打印 "车速有点快，系好安全带"
        当司机捕捉到SIGTSTP信号时，给售票员发送SIGUSER1信号。此时售票员打印 "到站了请下车"
      * 到站后 售票员先下车（子进程先退出）然后司机下车
  线程通信
     通信方法 ： 多个线程共用进程空间，所以进程的全局变量对进程内线程均可见。线程往往使用全局变量进行通信
     注意事项 ： 线程间使用全局变量进行通信，全局变量为共享资源，往往需要同步互斥机制
  线程的同步互斥
  线程Event
    创建对象：
        e = threading.Event()
    事件阻塞函数
        e.wait([timeout])
    设置事件
        e.set()
    清除事件
        e.clear（）
  线程锁  Lock
    lock = threading.Lock()   创建锁对象
    lock.acquire()  上锁
    lock.release()  解锁
    with  lock    上锁
  python线程的GIL问题 : GIL （全局解释器锁）
    python ---》 支持线程操作 ---》IO的同步和互斥 --》 加锁 ----》 超级锁，给解释器加锁
    后果 ： 一个解释器，同一时刻只解释一个线程，此时其他线程需要等待。大大降低了python线程的执行效率
    python  GIL问题解决方案
    * 修改c解释器
    * 尽量使用多进程进行并行操作
    * python线程可以用在高延迟多阻塞的IO情形
    * 不使用cpython     c#   java做解释器
  效率测试 : 分别测试 多进程  多线程  单进程执行相同的IO操作和CPU
    操作的时间
      Line cpu: 8.15166711807251
      Line IO: 6.841825246810913

      Thread cpu 8.414522647857666
      Thread IO 6.023292541503906

      Process cpu 4.079084157943726
      Process IO 3.2132551670074463
进程和线程的区别和联系
  1.两者都是多任务编程的方式，都能够使用计算机的多核
  2.进程的创建删除要比线程消耗更多的计算机资源
  3.进程空间独立，数据安全性好，有专门的进程间通信方法
  4.线程使用全局变量通信，更加简单，但是需要同步互斥操作
  5. 一个进程可以包含多个线程，线程共享进程的空间资源
  6. 进程线程都独立执行，有自己的特有资源如属性，id，命令集等
  使用情况：
  * 一个进程中并发任务比较多，比较简单，适合使用多线程
  * 如果数据程序比较复杂，特别是可能多个任务通信比较多的时候，要考虑到使用线程同步互斥的复杂性
  * 多个任务存在明显差异，和功能分离的时候没有必要一定写入到一个进程中
  * 使用python考虑线程GIL问题
  要求：
  1. 进程线程的区别和关系
  2. 进程间都信方式都用过哪些，有什么特点
  3. 同步和互斥是怎么回事，你都用哪些方法实现了同步互斥
  4. 什么是僵尸进程，怎么处理的
  5. python线程的效率怎么样？GIL是怎么处理的


服务器模型
  硬件服务器 ： 主机   集群
  厂商 ： IBM  HP  联想  浪潮
  软件服务器 ：编写的服务端程序，依托硬件服务器运行。 提供给用户一定的功能服务
服务器种类
  webserver ---》 网络的后端应用程序，提供数据处理和逻辑处理
  httpserver ---> 接受http请求，返回http响应
  邮箱服务器 ---》 处理邮件请求，进行邮件收发
  文件服务器 --》提供文件的上传下载存储
功能实现 ： 网络连接，逻辑处理，数据运算，数据交互
           协议实现，网络数据传输。。。。
模型结构 :    C/S   客户端服务器模型
             B/S    浏览器服务器模型
服务器目标：处理速度更快，数据安全性更强，并发量更高
硬件 ： 更高的配置，更好的硬件搭配，更高的网络速度 / 更多的主机，网络安全投入
软件 ： 占有更少的计算机资源，更稳定的运行效率，更流畅的速度，更强大的算法，更合理的技术搭配
网络服务器基础
  循环服务器 ： 单进程程序，循环接受客户请求，处理请求。处理完毕再接受下一个请求。
  特点 ： 每次只能处理一个客户端请求
          如果客户端长期占有服务器则无法处理其他客户端请求。
  优点 ： 实现简单，占用资源少
  缺点 ： 无法同时处理多客户端，体验差
  使用情况 ： 任务短暂，可以快速完成。udp比tcp更适合循环
  并发服务器 ： 能够同时处理多个客户端任务请求
      IO 并发  :  IO多路复用     协程
        优点 ： 可以实现IO的并发操作，占用系统资源少
        缺点 ： 不能监控cpu密集的情况，并能有长期阻塞
      多进程/多线程并发：为每个客户端单独提供一个进程/线程处理客户端请求
        优点 ： 客户端可以长期占有服务器
        缺点 ： 消耗计算机资源较多
多进程并发模型
  使用fork完成并发
  1. 创建套接字，绑定，监听
  2. 等待接受客户端连接请求
  3. 创建新的进程处理客户端请求
     父进程继续等待连接其他客户端
  4. 客户端退出 对应子进程结束

多线程并发:threading模块完成多线程并发
  对比多进程并发优点、缺点：
    优势 ： 资源消耗少
    缺点 ： 需要注意对共享资源的操作

  实现步骤：
  1. 创建套接字，绑定，监听
  2. 接收客户端连接请求，创建新的线程
  3. 主线程继续等待其他客户端连接，分支线程执行客户端具体请求
  4. 处理完客户端请求后分支线程自然退出，关闭客户端套接字




socket并发集成模块
  python2  SocketServer
  python3  socketserver
  功能 ： 通过模块提供的接口组合可以完成多进程/多线程  tcp/udp的并发程序

  StreamRequestHandler    处理tcp请求
  DatagramRequestHandler  处理udp请求

  ForkingMixIn   创建多进程
  ThreadingMixIn  创建多线程

  TCPServer  创建tcp  server
  UDPServer  创建udp  server

  ForkingTCPServer     ForkingMixIn  +  TCPServer
  ForkingUDPServer     ForkingMixIn  +  UDPServer
  ThreadingTCPServer   ThreadingMixIn  +  TCPServer
  ThreadingUDPServer   ThreadingMixIn  +  UDPServer

基于多线程并发的HTTPServer
  1. 接收浏览器http请求
  2. 对请求进行一定的解析
  3. 根据解析结果返回对应内容
  4. 如果没有请求内容则返回404
  5. 组织Response格式进行回发

  升级：
  * 使用多线程并发
  * 增加了具体的请求解析和404情况
  * 使用类进行代码封装
  * 增加一定的数据获取功能

  技术点 ： threading并发
            tcp socket 传输
            HTTP请求和响应格式










*************************cookie：****************************
位运算：按照二进制位进行运算操作
  & 按位与    | 按位或     ^ 按位异或
  << 左移       >>  右移
  11    1011
  14    1110
  --------------------------------
  &     1010   一0则0
  |     1111   一1则1
  ^     0101   相同0不同1
  11 << 2  ===> 44   右侧补0
  14 >> 2  ===> 3    挤掉右侧的数字
  -------------------------------------
  使用 ：  1. 在做底层硬件时操作寄存器
           2. 做标志位的过滤
linux下文件类型bcd-lsp
    b(块设备文件:驱动)   c（字符设备文件）
    d（目录）   -（普通文件）    l（链接文件：快捷方式）
    s（套接字文件：网络套接字看不到；本地套接字可以看到）    p（管道文件）
os 模块
  os.path.exists(file)
    功能 ： 判断一个文件是否存在
    参数 ： 文件
    返回值 ： 存在 True   不存在 False
  os.remove()
  os.unlink()
    功能 ： 删除一个文件
    参数 ： 要删除的文件
  os.listdir(path)：功能 : 获取文件列表
  os.path.isfile() : 判断一个 文件是否为普通文件
  os.path.isdir() ： 判断一个文件是否为目录
  size = os.path.getsize("./timg.jpeg") ##获取文件大小
首行添加  #！/usr/bin/python3
修改程序权限添加可执行权限  chmod  775  while.py
可以直接指明路径执行  ./while.py
##  网络连接测试用的telnet 127.0.0.1 8888  不灵活，只能通过Ctrl + C终止程序

要求：
  1.什么是进程，进程和程序的区别
  2.了解进程的特征和基本概念
  3.理解并发并行的区别
  4.清楚进程的状态及转换

项目初体验：（简单的群聊聊天室）
  功能 ： 类似于qq群聊
    1. 进入聊天室需要输入姓名 姓名不能重复
    2. 有人进入聊天室此时会向其他人发起通知
       xxx 进入了聊天室
    3. 如果一个人发消息，则其他人都能收到
       xxx 说 ： xxxxxxx
    4. 如果某个人退出聊天室其他人也会收到通知
       xxx 退出了聊天室
    5. 服务端可以喊话 ：此时群里所有人都能收到服务端消息
       管理员 说：xxx
  整体结构 ：分为几部分，如何封装，使用什么样的技术手段
    1.服务端   客户端
    2.在客户端和服务端每个功能封装为一个函数
    3.技术方案：
      转发 ： 一个客户端发送给服务器，服务器发送给其他人
      套接字使用 ：udp 完成操作
      用户存储： 字典 或者 列表  （可变类型，能够遍历提取）
                 地址  用户名
      发送和接受消息的控制：发送和接收使用多进程分离互不影响
    注意事项：
      1.注重封装（功能分开写）
      2.分段测试（写点测试点）
  代码编写流程:
    搭建通信  --》 创建多进程 ---》每个进程功能确定  --》 实现每一个功能模块
  功能细节梳理
    进入聊天室 login
       客户端 ：输入姓名
                将信息发送给服务器  L name
                接受到服务端返回结果判断下一步执行什么
       服务端 ： 接受消息
                 判断请求类型
                 判断是否可以登录（姓名是否已经存在）
                 返回给客户端是否登录（如果可以服务端会将姓名插入到存储结构）
                 给所有人发送消息

    进行聊天 chat
      客户端 ： 发起聊天  C name msg
                接受服务器回复
      服务器 ：  接受消息
                 判断消息类型
                 组织消息结构转发给其他客户端

    退出聊天室 quit
      客户端 ： 发送消息退出  Q  name
                接受回复
                退出程序
      服务端 ： 接受消息
                判断请求类型
                从用户结构删除对应用户
                告知所有人，xxx退出
    代码实现：
      import os, sys # os 用于创建进程；sys：用于文件的处理，退出进程
      from socket import * # 创建套接字，网络进程
              客户端                          服务端
      父进程  接收消息&做出处理            接收消息&做出处理给客户端
      子进程  发送消息给服务端    发送消息给自己，自己再转发给所有客户端
        ***注意（此处的说明是在开发过程中，最后的效果都是加了while True：的）：父进程发送消息：父进程结束后，会影响终端，提示行会首先打印出来，需要此时的父进程中加个while True:pass，不让父进程结束
                 所以选择：子进程发送消息

tftp 文件服务器
  项目功能 ：
    * 客户端有简单的页面命令提示
      * 功能包含：
        1. 查看服务器文件库中的文件列表（普通文件）
        2. 可以下载其中的某个文件到本地
        3. 可以上传客户端文件到服务器文件库
    * 服务器需求 ：
      1. 允许多个客户端同时操作
      2. 每个客户端可能会连续发送命令
  技术分析：
    1. tcp套接字更适合文件传输
    2. 并发方案  ---》 fork 多进程并发
    3. 对文件的读写操作
    4. 获取文件列表 ----》 os.listdir()
       粘包的处理
  整体结构设计
    1. 服务器功能封装在类中（上传，下载，查看列表）
    2. 创建套接字，流程函数调用  main（）
    3. 客户端负责发起请求，接受回复，展示
       服务端负责接受请求，逻辑处理
  编程实现
    1. 搭建整体结构，创建网络连接
    2. 创建多进程和类的结构
    3. 每个功能模块的实现
