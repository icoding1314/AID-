网络编程


网络目的 ： 数据传输

ISO(国际标准化组织)

OSI七层模型  ----》 网络通信的标准化流程

应用层 ： 提供用户服务， 具体的内容由特定的程序规定
表示层 ： 提供数据的加密和压缩优化
会话层 ： 确定建立应用连接，选择传输服务
传输层 ： 提供数据传输服务，进行流量控制
网络层 ： 路由选择，网络互联
链路层 ： 提供链路交换，具体消息的发送
物理层 ： 物理硬件，接口，网卡的规定

  网际互联及OSI七层模型：

  物理层、数据链路层、网络层、传输层、表示层、会话层、应用层

  ==========================================

  物理层

  作用：定义一些电器，机械，过程和规范，如集线器；

  PDU(协议数据单元)：bit/比特

  设备：集线器HUB;

  注意：没有寻址的概念；

  ==========================================

  数据链路层

  作用：定义如何格式化数据，支持错误检测；

  典型协议：以太网，帧中继（古董级VPN）

  PDU：frame（帧）设备：以太网交换机；

  备注：交换机通过MAC地址转发数据，逻辑链路控制；

  ===========================================

  网络层

  作用：定义一个逻辑的寻址，选择最佳路径传输，路由数据包；

  典型协议：IP，IPX，ICMP,ARP(IP->MAC),IARP;

  PDU:packet/数据包；

  设备：路由器

  备注：实现寻址

  ============================================

  传输层：

  作用：提供可靠和尽力而为的传输；

  典型协议：TCP,UDP,SPX,port(65535个端口),EIGRP,OSPF,

  PDU:fragment 段；

  无典型设备；

  备注：负责网络传输和会话建立；

  =============================================

  会话层：

  作用：控制会话，建立管理终止应用程序会话；

  典型协议：NFS, SQL, ASP, PHP, JSP, RSVP(资源源预留协议), windows， 

  备注：负责会话建立；

  ==============================================

  表示层：

  作用：格式化数据；

  典型协议：ASCII, JPEG. PNG, MP3. WAV, AVI, 

  备注：可以提供加密服务；

  ===============================================

  应用层：

  作用：控制应用程序；

  典型协议：telnet, ssh, http, ftp, smtp, rip, BGP, (未完待续)

  备注：为应用程序提供网络服务；

  ================================================

四层模型

应用层
传输层
网络层
物理链路层

五层模型（TCP/IP模型）

应用层  （应用层  表示层  会话层）
传输层
网络层
链路层
物理层

OSI模型优点 ： 将功能分开，降低网络传输中的耦合度。使                开发流程更加清晰，每部分各司其职

高内聚 ： 每个模块功能尽量单一，不会多个功能掺杂
低耦合 ： 尽量降低每个模块之间的关联性

要求 ： 能够顺序说出七层模型 五层模型
        知道每一层干什么事情
	理解消息传输流程

网络协议：在网络通信中协议各方必须遵守的规定。如建立           什么连接，消息结构如何解析等


应用层 ： TFTP   HTTP  DNS  SMTP 
传输层 ： TCP   UDP 
网络层 ：  IP 
物理层 ：  IEEE

网络相关概念

网络主机 ： 在网络上确定一台主机

本地使用 ： 'localhost'    127.0.0.1
  Localhost的意思是本地服务器，而127.0.0.1是本机地址，它们的关系是通过操作系统中的hosts文件，将Localhost解析为127.0.0.1。而实际工作中，Localhost是不经过网卡传输的，所以它不受网络防火墙和网卡的限制；而127.0.0.1则要通过网卡传输数据，是必须依赖网卡的
网络地址 ： '0.0.0.0'   '172.60.50.54' (本机网络IP)

查看本机IP地址：ifconfig    (linux)
                ipconfig     (windows)

ipython3   进入交互模式

通过计算机名获取匹配的IP
In [5]: socket.gethostbyname('tedu')
Out[5]: '127.0.1.1'

In [6]: socket.gethostbyname('localhost')
Out[6]: '127.0.0.1'

获取本机的计算机名
In [7]: socket.gethostname()
Out[7]: 'tedu'


IP地址

网络上确定一台主机的地址

IPv4： 点分十进制  比如 192.168.1.3   0--255 

IPv6   128位


网络连接测试
ping 172.60.50.180

特殊IP
127.0.0.1  本地测试IP
0.0.0.0    自动使用本地可用网卡IP
192.168.1.0  代表当前网段
192.168.1.1  通常为网关地址
192.168.1.255  广播地址


In [2]: socket.gethostbyaddr('www.baidu.com')
Out[2]: ('127.0.0.1', [], ['119.75.213.61'])
          主机       别名   IP地址

IP地址转换为十六进制表达
In [4]: socket.inet_aton('192.168.1.2')
Out[4]: b'\xc0\xa8\x01\x02'

In [5]: socket.inet_ntoa( b'\xc0\xa8\x01\x02')
Out[5]: '192.168.1.2'


域名：网络服务器地址在网络上的名称

端口号： 端口号是地址的一部分，在一个系统中每个网络         应用监听不同的端口，以获取对应端口传递的信息

取值范围 ： 1----65535
1-255  一些通用端口 （众所周知的程序占用）
256 --1023   系统端口
1024 --  65535  自用端口  >10000

获取应用程序端口
In [2]: socket.getservbyname('mysql')
Out[2]: 3306


传输层服务

面向连接的传输服务 ---》 tcp协议

传输特征：

可靠的数据传输
可靠性 ： 数据在传输中，无失序 无差错  无丢失 无重复 

在数据传输前和传输结束后需要建立连接和断开连接

三次握手 ： 在面向连接的传输服务中建立连接的过程

1. 客户端向服务器发送连接请求
2. 服务器接受到请求进行确认，返回确认报文
3. 客户端收到服务器回复最终确认连接

四次挥手 ： 在面向连接的传输服务站断开连接的过程

1. 主动方发送报文，告知被动方要断开连接
2. 被动方回复报文，表示已经接收到请求，准备断开
3. 被动方再次发送报文，表示准备处理就绪，可以断开
4. 主动发发送确认报文，断开连接

应用情况 ： 适用于传输较大的内容或文件，网络良好，需             要保证传输可靠性的情况
e.g.  聊天信息   文件的上传下载， 邮件处理
      网页获取

面向无连接的传输服务 ---》 udp协议

传输特点：
不保证传输的可靠性
没有连接和断开的过程
数据的首发比较自由

适用情况 ： 网络情况可能产生丢包，对传输可靠性要求低

e.g.  ： 网络视频，  群聊，广播等

要求：
1. 理解三次握手和四次挥手，能够描述过程
2. 知道tcp传输和udp传输的区别


socket 套接字编程

目的 ： 通过编程语言提供的套接字编程接口，可以更简单的完成基于tcp和udp的编程

套接字 ： 完成上述目标的一种编程手段

套接字类别 

流式套接字（SOCK_STREAM）：传输层基于tcp的协议通信
       面向连接可靠的传输   tcp的传输   流式套接字

数据报套接字（SOCK_DGRAM）： 传输层基于udp协议传输
   面向无连接不可靠的传输   udp的传输   数据报套接字

底层套接字 （SOCK_RAM）: 访问底层协议套接字


TCP的服务端

import socket

1. 创建套接字

socket.socket(sock_family = AF_INET,
              sock_type = SOCK_STREAM,
	      proto = 0)
功能 ： 创建套接字
参数 ： sock_family  地址族类型 AF_INET ipv4网络通信
        sock_type   套接字类型  SOCK_STREAM 流式
	                        SOCK_DGRAM  数据报
	proto  通常为0  选定子协议类型
返回值 ： 返回套接字对象

2. 绑定地址

sockfd.bind(addr)
功能 ： 绑定地址
参数 ： addr  ---》 元组 （ip,port） ('0.0.0.0',1234)

3. 设置监听套接字

sockfd.listen(n)
功能： 将套接字设置为监听套接字，创建监听队列
参数： 监听队列大小

* 一个监听套接字可以连接多个客户端

4. 等待接受客户端连接

connfd,addr = sockfd.accept()
功能 ： 阻塞等待处理客户端连接
返回值 ： connfd  新的套接字，用于和客户端通信
          addr  连接的客户端的地址 （ip,port） 


* 阻塞函数 ： 当程序运行到阻塞函数位置，如果某种条件没有达成则暂停程序运行，知道条件达成结束阻塞

5. 消息的收发

data = connfd.recv(buffersize)
功能 ： 接受消息
参数 ： 一次接受消息的大小  字节
返回值 ： 返回接受到的内容

n = connfd.send(data)
功能 ： 发送消息
参数 ： 要发送的内容 （bytes格式）
返回值 ： 返回实际发送的字节数

6. 关闭套接字

sockfd.close()

* telnet  ip   port

客户端

1. 创建套接字 （和服务端套接字类型相同）
2. 发起连接

connect（addr）
功能 ： 向服务端发起连接
参数 ： 服务端地址   元组

3. 消息收发 
4. 关闭套接字

recv()  特征
* 如何连接的另一端断开连接，则recv立即返回空子串
* recv是从接受缓冲区取出内容，当缓冲区为空则阻塞
* recv如果一次接受不完缓冲区内容，下次会继续接收

send() 特征
* 如果发送的另外一段不存在则会产生Pipe Broken
* recv是向发送缓冲区发送内容，当缓冲区为满阻塞



网络的收发缓冲区

在内存中开辟的区域，用作发送和接受的缓冲

* 协调数据收发（接受和处理）速度
* 减少和磁盘的交互


sendall(data)
功能 ： tcp套接字发送消息
参数 ： 同send
返回值：如果发送成功返回None


tcp粘包

产生原因： 
* tcp传输以字节流的方式发送消息，消息之间没有边界
* 发送比接受的速度快

影响 ： 对每次发送的内容是一个独立的意思需要单独识别

如何处理:
1. 每次发送后加一个结尾标志
2. 发送一个数据结构
3. 每次发送有一个间隔


基于UDP的服务端编程

1. 创建套接字

sockfd = socket(AF_INET,SOCK_DGRAM)

2. 绑定地址
sockfd.bind()

3. 消息收发

data,addr = sockfd.recvfrom(buffersize)
功能： 接受UDP消息
参数： 每次最多接受消息的大小  字节
返回值：data 接收到的内容
        addr 消息发送方的地址

* recvfrom每次接收一个报文，如果没有接收完全则丢弃没有收到的内容

sockfd.sendto(data,addr)
功能： UDP消息发送
参数： data  要发送的内容   bytes
       addr  目标地址
返回：发送字节数

4. 关闭套接字
sockfd.close()


cookie ： 

import  sys 
sys.argv
作用 ： 获取从命令行得到的参数内容
sys.argv[0] 是命令本身


tcp流式套接字和udp数据报套接字区别
1. 流式套接字采用字节流方式进行传输，而数据报套接字    使用数据报形式传输数据
2. tcp套接字会产生粘包，udp不会
3. tcp编程可以保证消息的完整性，udp则不能保证
4. tcp需要listen  accept，udp不用
5. tcp消息的发送接收使用recv  send  sendall，udp使用    recvfrom，sendto

要求 ： 能够说出tcp，udp协议的区别和编程实现上的差异


soccket模块和套接字属性
（s为套接字）

套接字属性
s.type :  表示套接字类型
s.family : 地址类型

套接字属性方法 
s.fileno()
功能 ： 获取套接字的文件描述符
文件描述符 ： 每一个IO事件操作系统都会分配一个不同的正整数与之匹配，该整数即为此IO的文件描述符

sys.stdin   0
sys.stdout  1
sys.stderr  2

s.getsockname()
功能 ： 获取套接字绑定的地址

s.getpeername()
功能 ： 获取连接套接字客户端的地址

s.setsockopt(level,optname,value)
功能 ： 设置套接字选项
参数 ： level   设置选项的类型   SOL_SOCKET
        optname   子类选项
  value    要设置的值

s.getsockopt(level,optname)
功能 ： 获取套接字选项值
参数 ： level   要获取选项的类型   SOL_SOCKET
        optname   子类选项
返回值 ： 获取的值



udp套接字应用 ---》 广播（broadcast）

一点发送多点接收

目标地址 ： 广播地址  172.60.50.255

cookie

In [3]: s = "{} is a {}".format('Tom','boy')

In [4]: s
Out[4]: 'Tom is a boy'

In [5]: s = "{1} is a {0}".format('Tom','boy')

In [6]: s
Out[6]: 'boy is a Tom'


tcp应用 ---》 http传输

http协议 ---》 超文本传输协议

用途 ： 网站中浏览器获取网页的过程

        编写基于http协议的数据传输

特点 ： 
1. 应用层协议，传输层使用tcp服务
2. 简单，灵活，可以使用多种编程语言操作
3. 无状态的协议，即不记录用户的输入内容
4. http1.1  ---> http2.0  技术成熟度和稳定性

http请求（request）

请求格式：

请求行   具体的请求类别和请求内容

 GET            /            HTTP/1.1
请求类别     请求内容        协议版本

请求类别 ： GET   获取网络资源
            POST  提交一定的附加数据，得到返回结果
      HEAD   获取响应头
            PUT    更新服务器资源
      DELETE  删除服务器资源
      CONNECT  
      TRACE   用于测试
      OPTIONS  获取服务器性能信息

请求头  ： 对请求的具体描述

Accept:text/html

* 每一个键值对占一行，描述了一个特定信息

空行
请求体 ： 具体的参数或者提交的内容

get参数或者post提交的内容


http响应 （response）

响应格式：

响应行 ： 反馈具体的响应情况

HTTP/1.1     200        OK
协议版本   响应码    附加信息

响应码 ：   1xx  提示信息，表示请求已经接受
            2xx  响应成功
      3xx  响应需要重定向
      4xx  客户端错误
      5xx  服务端错误
常见响应码
200    成功
404    请求内容不存在
401    没有访问权限
500    服务器发生未知错误
503    服务器暂时无法执行
    

响应头 ： 对响应内容的具体描述

Content-Encoding: gzip
Content-Type: text/html

空行
响应体 ： 将客户端请求内容进行返回

要求 ：  知道http作用
        掌握http协议 请求和响应的格式以及每一部分做什么
        掌握http协议中请求的基本类型和作用
        知道http协议响应码的类型和表达含义
        了解通过http协议请求网页的流程

tcp应用之 httpserver

* 接收http请求
* 查看http请求
* 返回一个网页给客户端


IO:在内存中存在数据交换的操作可以认为是IO操作(输入输出)[IO  input  output]
  e.g. 
  1.内存和磁盘进行数据交换： 
    文件的读写  数据库更新
  2.内存和终端数据交换 ： 
    input   print  
    sys.stdin sys.stdout  sys.stderr
  3.内存和网络数据的交换： 
    网络连接  recv  send  sendto recvfrom
  IO密集型程序 ： 程序执行中有大量的IO操作，而较少的cpu运算操作。消耗cpu较少，IO运行时间长
  CPU(计算)密集型程序：程序中存在大量的cpu运算，IO操作相对较少，消耗cpu大。
  IO分类
    阻塞IO   非阻塞IO    IO多路复用  事件驱动IO  异步IO
  阻塞IO ：  程序运行中遇到IO条件没有达成或者传输过从较慢的情况会出现阻塞状态

    * 阻塞IO是 IO最简单的逻辑情形，也是默认状态
    * 阻塞IO是效率很低的IO形态

    阻塞情况 ：
      * 因为某种IO条件没有达到形成阻塞
       e.g.   accept  recv   recvfrom   input

      * 处理IO事件的时候耗时较长形成阻塞
       e.g.  文件读写过程， 网络数据发送过程
  非阻塞IO ： 在程序运行中遇到IO的情形不让其产生阻塞
    实现手段： 
      改变IO事件的属性，使其变为非阻塞
        * 通常会和循环一起使用，进行条件的循环监控
        s.setblocking(False)
        功能 ： 将套接字设置为非阻塞
        参数 ： 默认为阻塞状态 设置为False则为非阻塞
      超时检测：将原本阻塞的函数，设置一个阻塞的最长时间。在时间内如果仍然阻塞则不再等待
        s.settimeout(sec)
        功能 ： 设置套接字的超时时间
        参数 ： 时间 （秒）
  IO多路复用：通过一个监测，可以同时监控多个IO事件的行为。当哪个IO事件可以执行，即让这个IO事件发生。
      IO事件就绪: IO事件即将发生的一个临界状态
      * 在程序中存在的IO事件中选择要监测的
      * 创建监测，将监测的IO事件注册
      * 等待监测的IO事件发生，判断是什么IO事件
      * 处理相应的IO
  IO多路复用的实现模块：select   poll  epoll
    select  ---》 windows   linux   unix
    poll ---》 linux  unix
    epoll ---》 linux   unix
  select方法实现IO多路复用
    import  select
    rs, ws, xs = select(rlist, wlist, xlist[, timeout])
    功能 ： 监控IO事件，阻塞等待监控的IO事件发生
    参数 ：  rlist   列表  存放我们需要等待处理的IO 处理完.remove(r) 如：s:accept
            wlist   列表  存放我们想主动处理的IO 处理完.remove(w) 如：c:接收、发送消息
            xlist   列表  存放出错希望去处理的IO 如：
            timeout  超时检测

    返回值: rs   列表  rlist中准备就绪的IO
            ws   列表  wlist中准备就绪的IO，有数据就立即返回，但是用的较少
            xs   列表  xlist中准备就绪的IO

    * 在处理IO时不要 （形成死循环，让一个客户端单独占有服务端）
    * IO多路复用形成一种可以同时处理多个IO的效果，效率较高
    * 有新的就append()
    * 处理完，记得remove()
  poll方法实现IO多路复用
    import select
    1. 创建poll对象
      p = select.poll()
    2. 注册关注的IO
      p.register(s,POLLIN | POLLERR)
      p.unregister(s)   取消IO关注
      事件类别
        POLLIN   POLLOUT   POLLERR   POLLHUP   POLLPRI   
        rlist    wlist     xlist     断开      紧急处理
    3. 监控IO 
      events = p.poll()
      功能  ： 监控关注的IO事件
      返回值： 返回发生的IO事件
       events 是一个列表  [(fileno,evnet),(),()....]
       每个就绪IO对应列表中一个元组：（描述符，就绪事件）
       IO地图 ： {s.fileno():s}

    4. 处理IO事件
  epoll方法实现IO多路复用
    import select
    使用方法： 代码与poll基本一致
    * 将生产的对象 改为  p = epoll() 
    * 将关注事件类别名称改为epoll的关注事件类别
      即：POLLXXX  -->>> EPOLLXXX
  epoll 与 poll 区别 :  （在C语言中，epoll复杂于poll；而python中进行了封装，看起来较简单）
    epoll 效率要高于select  和 poll
    epoll 的触发机制更多--> EPOLLET(边缘触发)【快递员送快递，人不在，去别家，回过头再邮递】

本地套接字 -->>> 作用 ： 用于本地不同程序间进行数据传输
  本地套接字传输流程
  1. 创建套接字对象
    sockfd = socket(AF_UNIX,SOCK_STREAM)
  2. 绑定套接字文件，如果文件不存在则自动创建
    sockfd.bind(file)
  3. 监听 listen
  4. 消息收发  recv  send

网络基础总结
  理论 ：
    1. OSI七层模型  tcp/ip模型
    2. TCP 和  UDP的区别和特征
    3. 三次握手和四次挥手的过程和每一次作用
    4. 什么是IO多路复用，IO的基本形态
    5. 套接字的种类，套接字类型的区别
  程序实践 ：
    1. TCP套接字传输的基本模型
    2. UDP套接字传输基本模型
    3. IO多路复用select poll的使用
    4. HTTP协议基本原理的实现

